<?xml version="1.0" encoding="utf-8"?>
<!--
	 @作者：HUBO
	 @创建时间：2011-12-26
	 @邮件：hubo.0508@gmail.com
-->
<s:Group xmlns:fx="http://ns.adobe.com/mxml/2009"
		 xmlns:s="library://ns.adobe.com/flex/spark"
		 xmlns:mx="library://ns.adobe.com/flex/mx"
		 xmlns:ns="library://FExt.HU" 
		 creationComplete="group1_creationCompleteHandler(event)"
		 height="200">
	
	<fx:Script>
		<![CDATA[
			import mx.collections.ArrayCollection;
			import mx.core.IVisualElement;
			import mx.events.FlexEvent;
			
			import org.hu.fextjs.components.Container;
			import org.hu.fextjs.components.RoundNode;
			
			import spark.components.Label;
			
			//历史颜色
			private var historyOfColor:uint;
			
			//周末工作日背景
			private var weekendColor:uint = 0xF1F8FE;
			
			private var columnOverColor:uint = 0xF9DFE0;
			
			//坐标
			private var basePoint:Point=new Point();
			
			//取值key
			private var _field:String = "price";
			
			//列宽
			private var columnWidth:int = 16;
			
			//存储最大值与最小值
			private var numericalIdentification:Array;
			
			//是否周末
			private var weekendCount:int = 0;
			
			//y空闲高度
			private var yTop:int = 30;
			
			//x-axis scale
			private var yCalibrationNumber:int = 3;
			private var _yCalibrationValue:Array;
			
			private var data:ArrayCollection;
			
			private var _unit:String = "";
			
			protected function group1_creationCompleteHandler(event:FlexEvent):void
			{
				//this.draw(data);
			}

			public function dataProvider(data:ArrayCollection):void
			{
				this.data = data;
				
				this.initChartContainer(data.length+3);
				this.draw(data);
			}
			
			private function initChartContainer(num:int):void
			{
				weekendCount = 0;
				for(var i:int=0; i<num; i++)
				{
					var contaier:Container;
					if(isWeekend()){
						contaier= this.createChildContainer(i+"",columnWidth,weekendColor);
					}else{
						contaier= this.createChildContainer(i+"",columnWidth);
					}
					
					this.chartContainer.addElement(contaier);
				}
			}
			
			private function isWeekend():Boolean
			{
				weekendCount++;
				if(weekendCount == 6 || weekendCount == 7)
				{
					if(weekendCount == 7){
						weekendCount = 0
					}
					return true;
				}
				return false;
			}
			
			protected function draw(data:ArrayCollection):void
			{
				if(data == null || data.length == 0) return;
				
				this.chartLine.graphics.clear();
				this.chartRound.removeAllElements();
				
				this.numericalIdentification  = this.getMaximumAndMinimumValues(data);
				
				this.drawYCalibration();
				
				this.drawLine(data);
			}	
			
			private function drawLine(data:ArrayCollection):void
			{
				chartLine.graphics.lineStyle(1, 0x0066DD, 1, false, LineScaleMode.VERTICAL, CapsStyle.NONE, JointStyle.MITER, 10);
				basePoint.x = columnWidth*0.5;
				
				var len:int=data.length;
				for(var i:int=0; i<len; i++)
				{					
					var item:Object = data.getItemAt(i);
					basePoint.y = this.getYAxisShowsValue(int(item[field]));				
					
					this.drawRoundNode(i.toString());
					
					if(i==0){
						chartLine.graphics.moveTo(basePoint.x ,basePoint.y);
					}
					
					chartLine.graphics.lineTo(basePoint.x ,basePoint.y);
					
					basePoint.x  = basePoint.x+columnWidth;
				}
			}
			
			private function drawYCalibration():void
			{
				chartLine.graphics.lineStyle(1, columnOverColor, 1, false, LineScaleMode.VERTICAL, CapsStyle.NONE, JointStyle.MITER, 10);
				var yw:Number = this.chartContainer.numElements*columnWidth;
				if(this.yCalibrationValue && this.yCalibrationValue.length > 0)
				{
					var len:int = this.yCalibrationValue.length;
					for(var i:int=0; i<len; i++)
					{
						var yaxisValue:Number = this.getYAxisShowsValue(yCalibrationValue[i]);
						chartLine.graphics.moveTo(0,yaxisValue);
						chartLine.graphics.lineTo(yw,yaxisValue);
						
						//var yaxis:Label = this.createLabel(Math.floor(yaxisValue).toString());
						var yaxis:Label = this.createLabel(unit+" "+yCalibrationValue[i].toString());
						yaxis.x = yw-getTextWidth(yaxis,yaxis.text)-3;
						yaxis.y = (yaxisValue+3)-getTextHeight(yaxis,yaxis.text);
						
						this.chartAxis.addElement(yaxis);
					}
				}
				else
				{
						
				}
			}
			
			private function getTextWidth(label:Label,text:String):int
			{
				label.regenerateStyleCache( false ); 
				var textMetrics:TextLineMetrics = label.measureText(text); 
				return textMetrics.width;
			}
			
			private function getTextHeight(label:Label,text:String):int
			{
				label.regenerateStyleCache( false ); 
				var textMetrics:TextLineMetrics = label.measureText(text); 
				return textMetrics.height;
			}
			
			private function drawRoundNode(index:String):void
			{
				var node:RoundNode = new RoundNode();
				node.x = basePoint.x-node.width*0.5;
				node.y = basePoint.y-node.width*0.5;
				node.id = index;
				
				this.chartRound.addElement(node);
			}
			
			/** 
			 * 画线 
			 * @param g 
			 * @param fromX 
			 * @param fromY 
			 * @param toX 
			 * @param toY 
			 * @param solidLen      实线长度 
			 * @param brokenLen     虚线间隔 
			 */  
			public function drawBrokenLine(g:Graphics,fromX:Number,fromY:Number,toX:Number,toY:Number,solidLen:Number=5,brokenLen:Number=0):void  
			{  
				//如果间隔为0,直接画实线  
				if(brokenLen == 0 || solidLen == 0)  
				{  
					g.moveTo(fromX,fromY);  
					g.lineTo(toX,toY);  
					return;  
				}  
				//如果间隔不为0,画虚线  
				var xOffset:Number = toX - fromX;  
				var yOffset:Number = toY - fromY ;  
				//正切角度值  
				var atan:Number = Math.atan2(yOffset,xOffset);  
				//线的总长度  
				var totalLen:Number =Math.sqrt(Math.pow(xOffset,2)+Math.pow(yOffset,2));  
				//已经画线长度  
				var len:Number = 0;  
				//当前循环是否画实线  
				var isDrawSolid:Boolean = true;  
				var tempFX:Number = fromX;  
				var tempFY:Number = fromY;  
				while(totalLen>len)  
				{  
					len = isDrawSolid ? len + solidLen : len + brokenLen;  
					//利用三角函数,计算该段终点坐标  
					var tempTX:Number = Math.cos(atan)*len + fromX;  
					var tempTY:Number = Math.sin(atan)*len + fromY;  
					if(isDrawSolid)  
					{  
						g.moveTo(tempFX,tempFY);  
						g.lineTo(tempTX,tempTY);  
					}  
					isDrawSolid = !isDrawSolid;  
					tempFX = tempTX ;  
					tempFY = tempTY ;  
				}  				
			}  
			
			private function getYAxisShowsValue(value:int):Number
			{
				var maximum:int = int(numericalIdentification["maximum"]);
				var chartContainerH:Number = chartContainer.height-yTop;
				if(maximum < chartContainerH || maximum > chartContainerH)
				{					
					return chartContainerH-((chartContainerH/maximum)*value)+yTop;
				}	
				
				if(maximum == chartContainerH)
				{
					return value;
				}	
				
				return 0;
			}
			
			private function getMaximumAndMinimumValues(data:ArrayCollection):Array
			{
				var maximum:int = 0;
				var minimum:int  = 0;
				var len:int = data.length;
				for(var i:int=0; i<len; i++)
				{
					var item:Object = data.getItemAt(i);
					var num:int = int(item[field]);
					
					maximum = maximum < num ? num : maximum;
					minimum = minimum < num ? minimum : num;
				}
				
				var arr:Array = [];
				arr["maximum"] = maximum;
				arr["minimum"] = minimum;
				
				return arr;
			}
			
			private function clearCacheColor(currentId:String):void
			{
				
//				var id:int = int(currentId);
//				id = id < 0 ? 0 : id;
//				var upColumnChart:Container = this.chartContainer.getElementAt(id) as Container;
//				if(upColumnChart.name == MouseEvent.ROLL_OVER)
//				{
//					upColumnChart.name = MouseEvent.ROLL_OUT;
//					upColumnChart.backgroupColor = getBgColor(id+1);
//					upColumnChart.invalidateDisplayList();
//				}
				
				var len:int = this.chartContainer.numElements;
				for(var i:int=0; i<len; i++)
				{
					var obj:Object = Object(chartContainer.getElementAt(i));
					if(obj.name == MouseEvent.ROLL_OVER)
					{
						obj.name = MouseEvent.ROLL_OUT;
						obj.backgroupColor = getBgColor(i+1);
						obj.invalidateDisplayList();
					}
				}				
			}
			
			private function getBgColor(value:int):uint
			{
				if(value == 0)
				{
					return 0xFFFFFF;
				}
				trace(value+" % 6 = " + value % 6 + "  | "+value+" % 7 = "+value % 7);
				if(value % 6 == 0 || value % 7 == 0){
					return weekendColor;
				}
				
				return 0xFFFFFF;
			}
			
			protected function chartColumnRollHandler(event:MouseEvent):void
			{					
				var chartColumn:Container = event.currentTarget as Container;					
				var targetId:String = Object(event.relatedObject).id;
				//trace(event.type+" | " + targetId+" | chartColumn.id "+chartColumn.id);				
					
				//
				if(targetId == "chartLine" || targetId == "chartRound" || targetId == "chartAxis")
				{
					return;
				}else{
					this.clearCacheColor(chartColumn.id);
				}											
				//trace("++++++++++++++++++执行++++++++++++++++++++");
				
				switch(event.type)
				{
					case MouseEvent.ROLL_OUT:							
						chartColumn.backgroupColor = historyOfColor;		
						chartColumn.name  = MouseEvent.ROLL_OUT;
						break;
					
					case MouseEvent.ROLL_OVER:
						historyOfColor = chartColumn.backgroupColor;
						chartColumn.backgroupColor = columnOverColor;		
						chartColumn.name = MouseEvent.ROLL_OVER;
						break;
					
					default:
						break;
				}
				chartColumn.invalidateDisplayList();					
				this.changeRoundStyle(int(chartColumn.id),event.type);		
			}	
			
			protected function changeRoundStyle(index:int, type:String):void
			{
				var roundNode:RoundNode = this.chartRound.getElementAt(index) as RoundNode;
				var upColor:uint = 0;
				switch(type)
				{
					case MouseEvent.ROLL_OUT:
						upColor = roundNode.solidColor;
						roundNode.solidColor = roundNode.contentColor;
						roundNode.contentColor = upColor;
						break;
					
					case MouseEvent.ROLL_OVER:					
						upColor = roundNode.solidColor;
						roundNode.solidColor = roundNode.contentColor;
						roundNode.contentColor = upColor;
						break;
					
					default:
						break;
				}
			}
			
			private function createChildContainer(index:String,width:Number,backgroupColor:uint = 0xFFFFFF):Container
			{				
				var container:Container = new Container();
				container.addEventListener(MouseEvent.ROLL_OVER,chartColumnRollHandler,false,0,true);
				container.addEventListener(MouseEvent.ROLL_OUT,chartColumnRollHandler,false,0,true);
				container.addEventListener(flash.events.FocusEvent.FOCUS_OUT,chartColumnFocusHandler,false,0,true);
				container.borderSides = "left";
				container.percentHeight=100;
				container.width = width;				
				container.backgroupColor = backgroupColor;
				container.id = index;
				container.name = MouseEvent.ROLL_OUT;
				
				return container;
			}
			
			private function createLabel(text:String):Label
			{
				var label:Label = new Label();
				label.text = text;
				
				return label;
			}
			
			protected function chartColumnFocusHandler(event:FocusEvent):void
			{

			}

			public function get field():String
			{
				return _field;
			}

			public function set field(value:String):void
			{
				_field = value;
			}

			public function get yCalibrationValue():Array
			{
				return _yCalibrationValue;
			}

			public function set yCalibrationValue(value:Array):void
			{
				_yCalibrationValue = value;
			}

			public function get unit():String
			{
				return _unit;
			}

			public function set unit(value:String):void
			{
				_unit = value;
			}
			

		

		]]>
	</fx:Script>

	<ns:HContainer id="chartContainer" borderColor="#CECECE" height="100%" gap="0" />	
	<s:Group id="chartLine" height="{chartContainer.height}" width="{chartContainer.width}" />	
	<s:Group id="chartRound" height="{chartContainer.height}" width="{chartContainer.width}" />
	<s:Group id="chartAxis" height="{chartContainer.height}" width="{chartContainer.width}" />
	
</s:Group>
